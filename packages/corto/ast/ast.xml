<meta xmlns:meta="http://corto.io/meta">
    <meta:package name="corto" url="http://corto.io/doc/corto">
        <meta:package name="ast" url="http://corto.io/doc/corto/ast">
            <!-- Enumeration representing the values that can be represented in hyve -->
            <enum name="valueKind">
                <meta:scope>
                    <constant name="Bool"/>
                    <constant name="Char"/>
                    <constant name="Int"/>
                    <constant name="SignedInt"/>
                    <constant name="Float"/>
                    <constant name="Text"/>
                    <constant name="Enum"/>
                    <constant name="Ref"/>
                    <constant name="Nothing"/>
                </meta:scope>
            </enum>

            <function name="valueKindFromType(type type)" returnType="valueKind"/>
            <function name="report(string kind,string filename,uint32 line,uint32 column,string error,string token)"/>
            <function name="reportError(string filename,uint32 line,uint32 column,string error,string token)"/>
            <function name="reportWarning(string filename,uint32 line,uint32 column,string error,string token)"/>
            <function name="isOperatorAssignment(operatorKind operator)" returnType="bool"/>

            <!-- Enumeration representing the different treenode kinds -->
            <enum name="nodeKind">
                <meta:scope>
                    <constant name="BinaryExpr"/>
                    <constant name="CallExpr"/>
                    <constant name="CastExpr"/>
                    <constant name="CommaExpr"/>
                    <constant name="DeclarationExpr"/>
                    <constant name="DeclareExpr"/>
                    <constant name="DefineExpr"/>
                    <constant name="InitExpr"/>
                    <constant name="DeinitExpr"/>
                    <constant name="IfExpr"/>
                    <constant name="InitializerExpr"/>
                    <constant name="LiteralExpr"/>
                    <constant name="MethodExpr"/>
                    <constant name="NewExpr"/>
                    <constant name="PostfixExpr"/>
                    <constant name="TernaryExpr"/>
                    <constant name="UnaryExpr"/>
                    <constant name="UpdateExpr"/>
                    <constant name="StorageExpr"/>
                    <constant name="WaitExpr"/>
                    <constant name="WhileExpr"/>
                </meta:scope>
            </enum>

            <!-- Base node -->
            <class name="Node">
                <meta:scope>
                    <method name="init()" returnType="int16"/>
                    <member name="kind" type="nodeKind"/>
                    <member name="line" type="uint32" modifiers="readonly"/>
                    <member name="column" type="uint32" modifiers="readonly"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <meta:object name="Storage" type="class"/>

            <enum name="derefKind">
                <meta:scope>
                    <constant name="ByValue"/>
                    <constant name="ByReference"/>
                </meta:scope>
            </enum>

            <!-- Base expression node -->
            <class name="Expression" base="Node">
                <meta:scope>
                    <member name="type" type="type" modifiers="readonly"/>
                    <member name="isReference" type="bool" modifiers="readonly"/>
                    <member name="deref" type="derefKind" modifiers="readonly"/>
                    <method name="getType()" returnType="type"/>
                    <method name="getType_expr(Expression target)" returnType="type"/>
                    <method name="getType_type(type target)" returnType="type"/>
                    <virtual name="serialize(type dstType,word dst)" returnType="int16"/>
                    <method name="cast(type type,bool isReference)" returnType="ast::Expression"/>
                    <virtual name="fold()" returnType="ast::Expression"/>
                    <virtual name="getValue()" returnType="word"/>
                    <virtual name="toList()" returnType="list{Expression}"/>
                    <virtual name="hasSideEffects()" returnType="bool"/>
                    <virtual name="hasReturnedResource()" returnType="bool"/>
                    <function name="fromList(list{Expression} list)" returnType="Expression"/>
                    <function name="cleanList(list{Expression} list)"/>
                </meta:scope>
            </class>

            <!-- Comma expression node -->
            <class name="Comma" base="Expression" baseAccess="readonly">
              <meta:scope>
                  <method name="init()" returnType="int16"/>
                  <method name="construct()" returnType="int16"/>
                  <member name="expressions" type="list{Expression}" modifiers="private"/>
                  <method name="addExpression(Expression expr)" returnType="int16"/>
                  <method name="toList()" returnType="list{Node}"/>
                  <function name="addOrCreate(Expression list,Expression expr)" returnType="Expression"/>
                  <function name="insertOrCreate(Expression list,Expression expr)" returnType="Expression"/>
                  <virtual name="hasSideEffects()" returnType="bool"/>
                  <virtual name="hasReturnedResource()" returnType="bool"/>
                  <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
              </meta:scope>
            </class>

            <!-- Base literal node -->
            <class name="Literal" base="Expression" baseAccess="readonly">
                <meta:scope>
                    <method name="init()" returnType="int16"/>
                    <member name="kind" type="valueKind"/>
                    <virtual name="getValue()" returnType="word"/>
                </meta:scope>
            </class>

            <!-- Boolean literal -->
            <class name="Boolean" base="Literal" baseAccess="readonly">
                <meta:scope>
                    <method name="init()" returnType="int16"/>
                    <method name="serialize(type dstType,word dst)" returnType="int16"/>
                    <member name="value" type="bool"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Character literal -->
            <class name="Character" base="Literal" baseAccess="readonly">
                <meta:scope>
                    <method name="init()" returnType="int16"/>
                    <method name="serialize(type dstType,word dst)" returnType="int16"/>
                    <member name="value" type="char"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Integer literal -->
            <class name="Integer" base="Literal" baseAccess="readonly">
                <meta:scope>
                    <method name="init()" returnType="int16"/>
                    <method name="serialize(type dstType,word dst)" returnType="int16"/>
                    <member name="value" type="uint64"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Signed integer literal -->
            <class name="SignedInteger" base="Literal" baseAccess="readonly">
                <meta:scope>
                    <method name="init()" returnType="int16"/>
                    <method name="serialize(type dstType,word dst)" returnType="int16"/>
                    <member name="value" type="int64"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Floating point literal -->
            <class name="FloatingPoint" base="Literal" baseAccess="readonly">
                <meta:scope>
                    <method name="init()" returnType="int16"/>
                    <method name="serialize(type dstType,word dst)" returnType="int16"/>
                    <member name="value" type="float64"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Null literal -->
            <class name="Null" base="Literal" baseAccess="readonly">
                <meta:scope>
                    <method name="init()" returnType="int16"/>
                    <method name="serialize(type dstType,word dst)" returnType="int16"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Enumeration representing the different variable kinds -->
            <enum name="storageKind">
                <meta:scope>
                    <constant name="LocalStorage"/>
                    <constant name="ObjectStorage"/>
                    <constant name="MemberStorage"/>
                    <constant name="ElementStorage"/>
                    <constant name="TemporaryStorage"/>
                    <constant name="TemplateStorage"/>
                </meta:scope>
            </enum>

            <!-- Base variable node -->
            <class name="Storage" base="Expression" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="kind" type="storageKind"/>
                </meta:scope>
            </class>


            <!-- Different kinds of locals -->
            <enum name="LocalKind">
                <meta:scope>
                    <constant name="LocalDefault"/>
                    <constant name="LocalParameter"/>
                    <constant name="LocalReturn"/>
                </meta:scope>
            </enum>

            <!-- Local variable node -->
            <class name="Local" base="Storage" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="name" type="string"/>
                    <member name="type" type="type"/>
                    <member name="kind" type="ast::LocalKind"/>
                    <member name="reference" type="bool"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Temporary storage node -->
            <class name="Temporary" base="Storage" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="type" type="type"/>
                    <member name="reference" type="bool"/>
                    <member name="proxy" type="Temporary" modifiers="private|local"/>
                    <member name="ic" type="ic::node" modifiers="private|local"/>
                    <method name="setProxy(Temporary proxy)"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Observer template variable -->
            <class name="Template" base="Local">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                </meta:scope>
            </class>

            <!-- Object variable node -->
            <class name="Object" base="Storage" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <method name="serialize(type dstType,word dst)" returnType="int16"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                    <method name="getValue()" returnType="word"/>
                    <member name="value" type="object"/>
                </meta:scope>
            </class>

            <!-- Explicitly init storage -->
            <class name="Init" base="Expression" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="storage" type="ast::Storage"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Explicitly deinit storage -->
            <class name="Deinit" base="Expression" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="storage" type="ast::Storage"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Forward declaration of while -->
            <meta:object name="While" type="class"/>

            <!-- Statement block -->
            <class name="Block" base="Node" baseAccess="readonly">
                <meta:scope>
                    <member name="parent" type="ast::Block"/>
                    <member name="isRoot" type="bool" modifiers="readonly"/>
                    <member name="statements" type="list{ast::Node}" modifiers="private|local"/>
                    <member name="locals" type="list{ast::Local}" modifiers="private|local"/>
                    <member name="function" type="function" modifiers="readonly"/>
                    <member name="while" type="ast::While" modifiers="readonly"/>
                    <method name="setFunction(function function"/>
                    <method name="declare(string id,type type,bool isParameter,bool isReference)" returnType="ast::Local"/>
                    <method name="declareTemplate(string id,type type,bool isParameter,bool isReference)" returnType="ast::Template"/>
                    <method name="declareReturnVariable(function function)" returnType="ast::Local"/>
                    <method name="lookup(string id)" returnType="ast::Expression"/>
                    <method name="lookupLocal(string id)" returnType="ast::Local"/> <!-- Only search for locals -->
                    <method name="resolve(string id)" returnType="ast::Expression"/>
                    <method name="resolveLocal(string id)" returnType="ast::Local"/>
                    <method name="addStatement(ast::Node statement)"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                    <virtual name="toIcBody(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Member expression -->
            <class name="Member" base="Storage" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="lvalue" type="ast::Expression"/>
                    <member name="rvalue" type="ast::Expression"/>
                    <member name="superMember" type="bool" modifiers="readonly"/>
                    <member name="member" type="object" modifiers="private"/> <!-- Only set when determined at compile-time -->
                    <virtual name="hasSideEffects()" returnType="bool"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Element expression -->
            <class name="Element" base="Storage" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="lvalue" type="ast::Expression"/>
                    <member name="rvalue" type="ast::Expression"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Call expression -->
            <class name="Call" base="Expression" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>

                    <member name="instanceExpr" type="ast::Expression"/>
                    <member name="arguments" type="ast::Expression"/>
                    <member name="functionExpr" type="ast::Expression" modifiers="readonly"/>
                    <member name="instanceIsAny" type="bool" modifiers="readonly"/>

                    <member name="returnType" type="type" modifiers="readonly"/>
                    <member name="returnsReference" type="bool" modifiers="readonly"/>
                    <member name="parameters" type="sequence{parameter}" modifiers="readonly"/>
                    <member name="overloaded" type="bool" modifiers="readonly"/>

                    <method name="setParameters(function function)"/>
                    <virtual name="hasSideEffects()" returnType="bool"/>
                    <virtual name="hasReturnedResource()" returnType="bool"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Compiler-defined function call -->
            <class name="StaticCall" base="Call">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="function" type="function"/>
                </meta:scope>
            </class>

            <!-- Runtime-defined (delegate) function call -->
            <class name="DelegateCall" base="Call">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="expr" type="ast::Expression"/>
                </meta:scope>
            </class>

            <!-- Helps finding the correct procedure given a name and argumentlist and build call expression -->
            <struct name="CallBuilder">
                <meta:scope>
                    <member name="name" type="string"/>
                    <member name="arguments" type="ast::Expression"/>
                    <member name="instance" type="ast::Expression"/>
                    <member name="scope" type="object"/>
                    <member name="block" type="ast::Block"/>
                    <member name="overloaded" type="bool" modifiers="local|private"/>
                    <member name="signature" type="string" modifiers="local|private"/>
                    <method name="buildSignature()" returnType="int16"/>
                    <method name="build()" returnType="ast::Call"/>
                </meta:scope>
            </struct>

            <!-- Cast expression -->
            <class name="Cast" base="Expression" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="lvalue" type="type"/>
                    <member name="rvalue" type="ast::Expression"/>
                    <member name="isReference" type="bool"/>
                    <virtual name="hasReturnedResource()" returnType="bool"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Postfix expression -->
            <class name="PostFix" base="Expression" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="lvalue" type="ast::Expression"/>
                    <member name="operator" type="operatorKind"/>
                    <virtual name="hasReturnedResource()" returnType="bool"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Unary expression -->
            <class name="Unary" base="Expression" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="lvalue" type="ast::Expression"/>
                    <member name="operator" type="operatorKind"/>
                    <virtual name="hasSideEffects()" returnType="bool"/>
                    <virtual name="hasReturnedResource()" returnType="bool"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Binary expression -->
            <class name="Binary" base="Expression" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="lvalue" type="ast::Expression"/>
                    <member name="rvalue" type="ast::Expression"/>
                    <member name="operator" type="operatorKind"/>
                    <member name="deref" type="ast::derefKind" modifiers="local|private"/>
                    <member name="isScalar" type="lang::bool" modifiers="local|readonly"/>
                    <method name="fold()" returnType="ast::Expression"/>
                    <method name="setOperator(operatorKind kind)" returnType="void"/>
                    <virtual name="hasSideEffects()" returnType="bool"/>
                    <virtual name="hasReturnedResource()" returnType="bool"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <meta:object name="If" type="class"/>

            <!-- Ternary expression -->
            <class name="Ternary" base="Expression" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="condition" type="ast::Expression"/>
                    <member name="ifTrue" type="ast::Expression"/>
                    <member name="ifFalse" type="ast::Expression"/>
                    <member name="ifTrueExpr" type="ast::Expression" modifiers="local|private"/>
                    <member name="ifFalseExpr" type="ast::Expression" modifiers="local|private"/>
                    <member name="result" type="ast::Expression"/>
                    <member name="ifstmt" type="ast::If" modifiers="local|private"/>
                    <method name="setOperator(operatorKind kind)" returnType="void"/>
                    <virtual name="hasSideEffects()" returnType="bool"/>
                    <virtual name="hasReturnedResource()" returnType="bool"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- New expression -->
            <class name="New" base="Expression" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="type" type="type"/>
                    <member name="attributes" type="ast::Expression"/>
                    <virtual name="hasSideEffects()" returnType="bool"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Define statement -->
            <class name="Define" base="Node" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="object" type="ast::Expression"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Text literal -->
            <class name="String" base="Literal" baseAccess="readonly">
                <meta:scope>
                    <method name="init()" returnType="int16"/>
                    <method name="construct()" returnType="int16"/>
                    <method name="serialize(type dstType,word dst)" returnType="int16"/>
                    <member name="value" type="string"/>
                    <member name="elements" type="list{ast::Expression}" modifiers="readonly"/>
                    <member name="block" type="ast::Block" modifiers="readonly"/>
                    <member name="scope" type="object" modifiers="readonly"/>
                    <method name="getValue()" returnType="word"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- If statement -->
            <class name="If" base="Node" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="condition" type="ast::Expression"/>
                    <member name="trueBranch" type="ast::Block"/>
                    <member name="falseBranch" type="ast::If"/>
                    <member name="warnUnreachable" type="bool" modifiers="private|local"/>
                    <method name="noWarnUnreachable()"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- While statement -->
            <class name="While" base="Node" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="condition" type="ast::Expression"/>
                    <member name="trueBranch" type="ast::Block"/>
                    <member name="isUntil" type="bool"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Update statement -->
            <enum name="UpdateKind">
                <meta:scope>
                    <constant name="UpdateDefault"/>
                    <constant name="UpdateBegin"/>
                    <constant name="UpdateEnd"/>
                </meta:scope>
            </enum>
            <class name="Update" base="Node" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="exprList" type="list{ast::Expression}"/>
                    <member name="block" type="ast::Block"/>
                    <member name="from" type="ast::Expression"/>
                    <member name="kind" type="ast::UpdateKind"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Wait expression -->
            <class name="Wait" base="Expression" baseAccess="readonly">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="exprList" type="list{ast::Expression}"/>
                    <member name="timeout" type="ast::Expression"/>
                    <virtual name="hasReturnedResource()" returnType="bool"/>
                    <virtual name="toIc(ic::program program,ic::storage storage,bool stored)" returnType="ic::node"/>
                </meta:scope>
            </class>

            <!-- Initializer -->
            <enum name="InitializerKind">
                <meta:scope>
                    <constant name="InitStatic"/>
                    <constant name="InitDynamic"/>
                    <constant name="InitExpression"/>
                </meta:scope>
            </enum>

            <!-- Initializer stack element -->
            <struct name="InitializerVariable">
                <meta:scope>
                    <member name="offset" type="word"/>
                    <member name="object" type="Expression"/>
                    <!-- Key-values (of associative collections) are serialized to this member -->
                    <member name="key" type="word"/>
                </meta:scope>
            </struct>

            <struct name="InitializerFrame">
                <meta:scope>
                    <member name="location" type="uint32"/>
                    <member name="type" type="type"/>
                    <member name="isKey" type="bool"/>
                    <member name="member" type="member"/>
                </meta:scope>
            </struct>

            <class name="Initializer" base="Expression" baseAccess="readonly">
                <meta:scope>
                    <member name="variables" type="array{InitializerVariable,64}"/>
                    <member name="variableCount" type="uint8"/>
                    <member name="frames" type="array{InitializerFrame,64}" modifiers="private|local"/>
                    <member name="fp" type="uint8" modifiers="private|local"/>
                    <method name="construct()" returnType="int16"/>
                    <method name="currentType()" returnType="type"/>
                    <method name="type()" returnType="type"/>
                    <virtual name="push()" returnType="int16"/>
                    <virtual name="pop()" returnType="int8"/>
                    <virtual name="value(Expression v)" returnType="int16"/>
                    <virtual name="member(string name)" returnType="int32"/>
                    <virtual name="pushKey()" returnType="int16"/>
                    <virtual name="popKey()" returnType="int16"/>
                    <virtual name="valueKey(Expression key)" returnType="int16"/>
                    <virtual name="define()" returnType="int16"/>
                    <virtual name="next()" returnType="int16"/>
                    <method name="initFrame()" returnType="uint16"/>
                </meta:scope>
            </class>

            <struct name="StaticInitializerFrame">
                <meta:scope>
                    <member name="ptr" type="array{word,64}"/>
                    <member name="keyPtr" type="array{word,64}"/>
                </meta:scope>
            </struct>

            <!-- A static initializer represents an object that is initialized during compiletime -->
            <class name="StaticInitializer" base="Initializer">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="frames" type="array{StaticInitializerFrame,64}" modifiers="private|local"/>
                    <method name="push()" returnType="int16"/>
                    <method name="value(Expression v)" returnType="int16"/>
                    <method name="define()" returnType="int16"/>
                </meta:scope>
            </class>

            <struct name="DynamicInitializerFrame">
                <meta:scope>
                    <member name="expr" type="array{ast::Expression,64}"/>
                    <member name="keyExpr" type="array{ast::Expression,64}"/>
                    <member name="sequenceSize" type="ast::Integer"/>
                </meta:scope>
            </struct>

            <!-- A dynamic initializer represents an object that is initialized during runtime -->
            <class name="DynamicInitializer" base="Initializer">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="assignValue" type="bool"/>
                    <member name="frames" type="array{DynamicInitializerFrame,64}" modifiers="private|local"/>
                    <method name="push()" returnType="int16"/>
                    <method name="pop()" returnType="int16"/>
                    <method name="value(Expression v)" returnType="int16"/>
                    <method name="define()" returnType="int16"/>
                    <virtual name="hasReturnedResource()" returnType="bool"/>
                </meta:scope>
            </class>

            <!-- Recorded Initializer operation -->
            <enum name="InitOperKind">
                <meta:scope>
                    <constant name="InitOpPush"/>
                    <constant name="InitOpPop"/>
                    <constant name="InitOpDefine"/>
                    <constant name="InitOpValue"/>
                    <constant name="InitOpMember"/>
                </meta:scope>
            </enum>
            <struct name="InitOper">
                <meta:scope>
                    <member name="kind" type="InitOperKind"/>
                    <member name="expr" type="ast::Expression"/>
                    <member name="name" type="string"/>
                </meta:scope>
            </struct>

            <!-- Record initializer for later evaluation -->
            <class name="InitializerExpression" base="Initializer">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <member name="assignValue" type="bool"/>
                    <member name="operations" type="list{InitOper}" modifiers="private|local"/>
                    <method name="push()" returnType="int16"/>
                    <method name="pop()" returnType="int16"/>
                    <method name="value(Expression v)" returnType="int16"/>
                    <method name="member(string name)" returnType="int32"/>
                    <method name="define()" returnType="int16"/>
                    <method name="insert(Expression variable)" returnType="int16"/>
                    <virtual name="hasReturnedResource()" returnType="bool"/>
                </meta:scope>
            </class>

            <!-- ParseDeclaration is used to transfer declaration-information within the parser -->
            <struct name="ParserDeclaration">
                <meta:scope>
                    <member name="name" type="string"/>
                    <member name="storage" type="ast::Storage"/>
                </meta:scope>
            </struct>

            <sequence name="ParserDeclarationSeq" elementType="ParserDeclaration" max="256"/>

            <!-- ParserNew is used to transfer new-expression information within the parser -->
            <struct name="ParserNew">
                <meta:scope>
                    <member name="kind" type="ast::nodeKind"/>
                    <member name="parent" type="ast::Expression"/>
                    <member name="name" type="ast::Expression"/>
                    <member name="attr" type="ast::Expression"/>
                </meta:scope>
            </struct>

            <!-- Binds function to an implementation -->
            <struct name="Binding">
                <meta:scope>
                    <member name="function" type="function"/>
                    <member name="impl" type="ast::Block"/>
                </meta:scope>
            </struct>

            <!-- Keep track of lvalue-stack and whether lvalue is an assignment or not -->
            <struct name="Lvalue">
                <meta:scope>
                    <member name="expr" type="ast::Expression"/>
                    <member name="isAssignment" type="bool"/>
                </meta:scope>
            </struct>

            <!-- Parser object -->
            <class name="Parser">
                <meta:scope>
                    <method name="construct()" returnType="int16"/>
                    <method name="destruct()"/>
                    <member name="source" type="string"/>
                    <member name="preprocessed" type="string" modifiers="readonly"/>
                    <member name="filename" type="string"/>
                    <member name="repl" type="uint32" modifiers="readonly"/> <!-- Is parser running in interpreted mode -->
                    <member name="line" type="uint32" modifiers="readonly"/>
                    <member name="column" type="uint32" modifiers="readonly"/>
                    <member name="token" type="string" modifiers="readonly"/>
                    <member name="block" type="ast::Block" modifiers="readonly"/>
                    <!-- Keep track of block-nesting in 1st pass -->
                    <member name="blockCount" type="uint32" modifiers="readonly"/>
                    <member name="scope" type="object" modifiers="readonly"/>
                    <member name="errors" type="uint32" modifiers="readonly"/>
                    <member name="warnings" type="uint32" modifiers="readonly"/>
                    <member name="errSet" type="bool" modifiers="readonly|private"/> <!-- If set the last operation on the parser returned an error -->
                    <member name="errLine" type="uint32" modifiers="readonly|private"/>
                    <member name="abort" type="bool" modifiers="readonly"/> <!-- If set the last operation on the parser indicated parsing should abort -->
                    <member name="bindings" type="list{ast::Binding}" modifiers="readonly"/>
                    <member name="pass" type="uint32" modifiers="private|local"/>
                    <method name="collectHeap(word addr)" returnType="void"/>
                    <member name="heapCollected" type="list{word}" modifiers="private|local"/>
                    <member name="collected" type="list{object}" modifiers="private|local"/>
                    <member name="blockPreset" type="bool" modifiers="private|local"/>
                    <member name="isLocal" type="bool" modifiers="private|local"/> <!-- If set, next declaration will result in local variable -->
                    <member name="parseSingleExpr" type="bool" modifiers="private|local"/> <!-- If set parser is parsing one instruction -->
                    <member name="singleExpr" type="ast::Expression" modifiers="private|local"/>
                    <!-- Due to limitations in the parser sometimes failed resolves can't be immediately reported.
                         This field keeps track of a failed resolve and will be used in a report if it causes issues. -->
                    <member name="lastFailedResolve" type="string" modifiers="private|local"/>

                    <!-- Variables prepared for initializer (maximum of 64 variables can be initialized simultaneously) -->
                    <member name="variables" type="array{ast::Storage,64}" modifiers="private|readonly"/>
                    <member name="variableCount" type="uint32" modifiers="private|readonly"/>
                    <!-- Have variables been initialized? (required for deciding whether to define or not) -->
                    <member name="variablesInitialized" type="bool" modifiers="private|readonly"/>

                    <!-- If variablePushed is TRUE it means that an object was pushed on the initializer stack without a
                         declaration (using parseInitPushVariable). The next parseInitPush doesn't have to push. -->
                    <member name="variablePushed" type="bool" modifiers="private|readonly"/>

                    <!-- An initializer can have a maximum depth of 64 -->
                    <member name="initializers" type="array{Initializer,64}" modifiers="private|local"/>
                    <member name="initializerCount" type="int8" modifiers="private|local"/>
                    <member name="initAnonymousId" type="uint32" modifiers="private|local"/>
                    <member name="initDynamic" type="bool" modifiers="private|local"/>

                    <!-- Stage unresolved variables for implicit declaration -->
                    <struct name="stagedId">
                        <meta:scope>
                            <member name="name" type="string"/>
                            <member name="found" type="bool"/>
                            <member name="line" type="uint32"/>
                            <member name="column" type="uint32"/>
                        </meta:scope>
                    </struct>
                    <member name="staged" type="array{stagedId,64}" modifiers="private|local"/>
                    <member name="stagedCount" type="uint32" modifiers="private|local"/>
                    <member name="stagingAllowed" type="bool" modifiers="private|local"/>

                    <!-- Parser framework functions -->
                    <method name="parse(sequence{string} argv)" returnType="uint32"/>
                    <function name="parseLine(string expr,object scope,word value)" returnType="int16"/> <!--  Parse a single line -->
                    <method name="parseExpression(string expr,ast::Block block,object scope,uint32 line,uint32 column)" returnType="ast::Expression"/>
                    <method name="isErrSet()" returnType="bool"/>
                    <method name="isAbortSet()" returnType="bool"/>
                    <method name="collect(object o)" returnType="void"/>
                    <method name="reset()"/>
                    <method name="argumentToString(type type,string id,bool reference)" returnType="string"/> <!-- Convert function argument to string -->

                    <!-- Scope management -->
                    <method name="pushScope()" returnType="object"/>
                    <method name="popScope(object previous)"/>
                    <method name="pushPackage(string name)" returnType="int16"/>

                    <!-- Lookup -->
                    <method name="lookup(string id)" returnType="ast::Expression"/>

                    <!-- Blocks management -->
                    <method name="blockPush(bool presetBlock)" returnType="ast::Block"/>
                    <method name="blockPop()"/>
                    <method name="addStatement(ast::Node statement)"/>

                    <!-- Declaration -->
                    <method name="declaration(type type,string id,bool isReference)" returnType="Storage"/>
                    <method name="declareFunction(type returnType,string id,type kind,bool returnsReference)" returnType="Storage"/>
                    <method name="declareFunctionParams(Storage function)" returnType="ast::Block"/>
                    <method name="define()" returnType="int16"/>
                    <method name="defineScope()" returnType="int16"/>
                    <method name="defineVariable(Storage object)" returnType="int16"/>

                    <!-- Bind function to implementation -->
                    <method name="bind(ast::Storage function,ast::Block block)" returnType="int16"/>
                    <method name="bindOneliner(ast::Storage function,ast::Block block,ast::Expression expr)" returnType="int16"/>

                    <!-- Finalize bound functions -->
                    <method name="finalize(ic::program program)" returnType="int16"/>

                    <method name="initStage(string id,bool found)"/>
                    <method name="initDeclareStaged(ast::Expression expr)"/>
                    <method name="initPushStatic()" returnType="int16"/>
                    <method name="initPushExpression()" returnType="Expression"/>
                    <method name="initPush()" returnType="int16"/>
                    <method name="initPushIdentifier(Expression type)" returnType="Expression"/>
                    <method name="initPop()" returnType="int16"/>
                    <method name="initValue(Expression expr)" returnType="int16"/>
                    <method name="initMember(string member)" returnType="int16"/>
                    <method name="initKeyValuePush()" returnType="int16"/>
                    <method name="initKeyValuePop()" returnType="int16"/>
                    <method name="initKeyValueSet(ast::Expression expr)" returnType="int16"/>

                    <!-- Set lvalue -->
                    <member name="lvalue" type="array{ast::Lvalue,64}" modifiers="private|local"/>
                    <member name="lvalueSp" type="int32" modifiers="private|local"/>
                    <method name="pushLvalue(ast::Expression lvalue,bool isAssignment)"/>
                    <method name="pushReturnAsLvalue(function function)"/>
                    <method name="popLvalue()"/>
                    <method name="getLvalue(bool assignment)" returnType="ast::Expression"/>
                    <method name="getLvalueType(bool assignment)" returnType="type"/>

                    <!-- This complex type is used to lookup member identifiers in element expression -->
                    <member name="complexType" type="array{type,64}" modifiers="private|local"/>
                    <member name="complexTypeSp" type="int32" modifiers="private|local"/>
                    <method name="pushComplexType(ast::Expression lvalue)"/>
                    <method name="popComplexType()"/>
                    <method name="getComplexType()" returnType="type"/>

                    <!-- Observer -->
                    <method name="observerPush()"/>
                    <method name="observerDeclaration(string id,ast::Expression object,eventMask mask,ast::Object dispatcher)" returnType="Storage"/>

                    <!-- Foreach -->
                    <method name="foreach(string loopId,ast::Expression collection)" returnType="int16"/>

                    <!-- Postfix expressions -->
                    <method name="callExpr(ast::Expression function,ast::Expression arguments)" returnType="ast::Expression"/>
                    <method name="memberExpr(ast::Expression lvalue,ast::Expression rvalue)" returnType="ast::Expression"/>
                    <method name="elementExpr(ast::Expression lvalue,ast::Expression rvalue)" returnType="ast::Expression"/>
                    <method name="castExpr(type lvalue,ast::Expression rvalue)" returnType="ast::Expression"/>

                    <!-- Arithmic expressions -->
                    <method name="postfixExpr(ast::Expression lvalue,operatorKind operator)" returnType="ast::Expression"/>
                    <method name="unaryExpr(ast::Expression lvalue,operatorKind operator)" returnType="ast::Expression"/>
                    <method name="binaryExpr(ast::Expression lvalues,ast::Expression rvalues,operatorKind operator)" returnType="ast::Node"/>
                    <method name="ternaryExpr(ast::Expression cond,ast::Expression iftrue,ast::Expression iffalse)" returnType="ast::Expression"/>

                    <!-- Wait expression -->
                    <method name="waitExpr(ast::Expression expr,ast::Expression timeout)" returnType="ast::Expression"/>

                    <!-- Loops and conditional statements -->
                    <method name="ifStatement(ast::Expression condition,ast::Block trueBranch,ast::If falseBranch)" returnType="ast::Node"/>
                    <method name="whileStatement(ast::Expression condition,ast::Block trueBranch,bool isUntil)" returnType="ast::Node"/>

                    <!-- Update -->
                    <method name="updateStatement(ast::Expression expr,ast::Block block)" returnType="ast::Node"/>
                </meta:scope>
            </class>
        </meta:package>
    </meta:package>
</meta>
