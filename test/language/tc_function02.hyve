// Functions with complex returntypes
bool result: true;
void fail(string msg):
	"tc_function02: FAIL: $msg";
	result = false;

struct Point::
	x, y: uint32;

struct Point3D: Point::
	z : uint32;

// Assign members of result-variable
Point toPoint(uint32 x, uint32 y):
	toPoint.x = x;
	toPoint.y = y;

var Point p = toPoint(10, 20);
if p[x, y] != (10, 20): fail("p[x, y] != (10, 20) ($p)");

// Copy value of argument to result through regular assignment
Point copyPoint(Point p): copyPoint = p;

var Point q = {10, 20};
var Point r = copyPoint(q);
if r[x, y] != (10, 20): fail("r[x, y] != (10, 20) ($r)");

// Copy value of argument to result value with short-hand notation
Point copyPointShort(Point p) = p;

var Point s = copyPointShort(q);
if s[x, y] != (10, 20): fail("s[x, y] != (10, 20) ($s)");

// Copy initializer value with short hand notation
Point copyPointInit(uint32 x, uint32 y) = {x, y};
var Point t = copyPointInit(10, 20);
if t[x, y] != (10, 20): fail("t[x, y] != (10, 20) ($t)");

// Copy initializer value with short hand notation and complex argument
Point copyPointInit(Point p) = {p.x, p.y};
var Point u = copyPointInit(q);
if u[x, y] != (10, 20): fail("u[x, y] != (10, 20) ($u)");

// Copy value larger than 8 bytes. This will trigger the memcpy return mechanism in the virtual machine.
Point3D copyPoint3D(Point3D p) = {p.x, p.y, p.z};
Point3D p3d: 10, 20, 30;
var Point3D v = copyPoint3D(p3d);
if v[x, y, z] != (10, 20, 30): fail("v[x, y] != (10, 20, 30) ($v)");

if result: "tc_function02: OK";